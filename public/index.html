<!DOCTYPE html>
<html>
<meta charset="utf-8">
<meta name=viewport content="width=device-width, initial-scale=1">
<title>besokind</title>
<style>
  body {
    margin: 0;
    font-family: -apple-system,BlinkMacSystemFont,Ubuntu,Roboto,Open Sans,Helvetica Neue,Helvetica,Arial,sans-serif;
    font-size: 14px;
    line-height: 16px;
  }
  ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  a {
    text-decoration: none;
    color: inherit;
  }
  a:hover {
    text-decoration: underline;
  }
  .light-btn {
    color: #555;
    text-decoration: none;
    cursor: pointer;
  }
  .light-btn:hover {
    text-decoration: underline;
  }
  .card-input::-webkit-input-placeholder { color: #333; }
  .card-input::-moz-placeholder { color: #333; }
  .card-input:focus::-webkit-input-placeholder { color: #ddd; }
  .card-input:focus::-moz-placeholder { color: #ddd; }
  .card-header__author-photo.online::after {
    content: "";
    background-color: limegreen;
    position: absolute;
    bottom: 0;
    right: 0;
    border: 2px solid #fff;
    border-radius: 0 0 4px 0;
    width: 10px;
    height: 10px;
  }
  .horizontal-list li {
    display: inline-block;
  }
  .nav-item {
    line-height: 48px;
    height: 48px;
    margin-right: 10px;
    color: bisque;
    cursor: pointer;
  }
  .nav-item:hover {
    text-decoration: underline;
  }
  .nav-item._disabled {
    color: #ffb494;
  }
  /*.nav-item._disabled:hover {
    text-decoration: none;
    cursor: default;
  }*/
  .notification-list {
    cursor: auto;
  }
  .notification-list li {
    display: block;
  }
  .notification-list li:first-child {
    border-radius: 5px 5px 0 0;
    padding-top: 4px;
    /*padding: 12px 10px 8px 10px;*/
  }
  .notification-list li:last-child {
    border-radius: 0 0 5px 5px;
    padding-bottom: 4px;
    /*padding: 8px 10px 12px 10px;*/
  }
  .notification-list li:hover {
    background: #f9f9f9;
  }
  .notification-list li div {
    padding: 8px 10px;
  }
  ._assigned {
    background: #f9f9f9;
  }
</style>

<div id="main"></div>

<script src="https://www.gstatic.com/firebasejs/3.5.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/3.5.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/3.5.0/firebase-database.js"></script>
<script src='date-fns-distance.js'></script>
<script src="app.js"></script>
<script>
  var config = {
    apiKey: "AIzaSyBenkychYMdGWfGBnjpxDAeEzR9hu60_f0",
    authDomain: "besokind-b837c.firebaseapp.com",
    databaseURL: "https://besokind-b837c.firebaseio.com",
    storageBucket: "besokind-b837c.appspot.com",
    messagingSenderId: "490319737092"
  };
  firebase.initializeApp(config);

  var auth = firebase.auth();
  var database = firebase.database();
  var dbCards = database.ref('cards');
  dbCards.off();



  function addCardToList(card) {
    card = card.val();
    card.creationTimeFriendly = dateFnsDistanceInWords(card.creationTime);
    app.ports.addCardToList.send(card);
  }

  function updateCard(card) {
    card = card.val();
    card.creationTimeFriendly = dateFnsDistanceInWords(card.creationTime);
    app.ports.updateCard.send(card);
  }


  /*
    depends on `dateFnsDistanceInWords`
  */
  function getCards(callback) {
    dbCards.limitToLast(12).on('child_added', addCardToList);
    dbCards.limitToLast(12).on('child_changed', updateCard);
  }


  function setUserPresence(isOnline) {
    if (auth.currentUser) {
      var updates = {};
      updates[auth.currentUser.uid] = isOnline ? true : null;
      database.ref('users-online')
        .update(updates)
        .then(function() {
          // body...
        })
        .catch(function(error) {
          console.error('## error during [setting user presence]:', error);
        });
    }
  }

  function notificationAdded(notification) {
    app.ports.notificationAdded.send(notification.val());
  }

  function notificationRemoved(notification) {
    app.ports.notificationRemoved.send(notification.val());
  }


  auth.onAuthStateChanged(function(user) {
    if (!user) return;

    var userRef = database.ref('users/' + user.uid);
    var userNotificationsRef = database.ref('user-notifications/' + user.uid)
    var userRoomsRef = database.ref('user-rooms/' + user.uid)

    userRef.once('value', function(snapshot) {
      var userInDb = snapshot.val();
      if (userInDb) {
        setUserPresence(true);
        app.ports.authStateChanged.send(userInDb);
      } else {
        // authorized for the first time -> create user
        var updates = {};
        var newUser = {
          uid: user.uid,
          name: user.displayName,
          email: user.email,
          photoURL: user.photoURL,
          karma: 0,
          moderator: false
        };
        updates['users/' + user.uid] = newUser;

        database.ref()
          .update(updates)
          .then(function() {
            setUserPresence(true);
            app.ports.authStateChanged.send(newUser);
          })
          .catch(function(error) {
            console.error('## error during [creating new user]:', error);
          });
      }
    }).catch(function(error) {
      console.error('## error during [getting user info]:', error);
    });


    // -- user related subscribes


    userNotificationsRef.limitToLast(12).on('child_added', notificationAdded);
    userNotificationsRef.on('child_removed', notificationRemoved);

    userRoomsRef
      .limitToLast(12)
      .on('child_added', function(room) {
        app.ports.roomAdded.send({ id: room.key, users: [], messages: [] });

        database.ref('room-messages/' + room.key)
          .limitToLast(1)
          .on('child_added', function(im) {
            app.ports.messageAdded.send({chatId: room.key, im: im.val()});
          });
      });

    userRef.child('lastOnline').onDisconnect().set(firebase.database.ServerValue.TIMESTAMP);

    database.ref('users-online').child(user.uid).onDisconnect().remove();
  });


  var app = Elm.Main.fullscreen();
  app.ports.windowResized.send(window.innerHeight || document.documentElement.clientHeight);


  app.ports.login.subscribe(function(authType) {
    switch (authType) {
      case 'google':
        auth.signInWithPopup(new firebase.auth.GoogleAuthProvider());
        break;
    }
  });

  app.ports.logout.subscribe(function() {
    if (auth.currentUser) {
      var uid = auth.currentUser.uid;
      setUserPresence(false);
      database.ref('users/' + uid + '/lastOnline').set(firebase.database.ServerValue.TIMESTAMP);
      database.ref('user-notifications/' + uid).off();
      database.ref('user-rooms/' + uid).off();
    }

    auth.signOut();

    app.ports.authStateChanged.send({
      uid: '',
      name: '',
      email: '',
      photoURL: '',
      karma: 0,
      moderator: false
    });
  });

  app.ports.removeNotification.subscribe(function(userId, notificationId) {
    database.ref('user-notifications/' + userId + '/' + notificationId).remove();
  });

  app.ports.fetchStreamCards.subscribe(getCards);

  app.ports.fetchCard.subscribe(function(id) {
    database.ref('cards/' + id).once('value', function(card) {
      card = card.val();
      card.creationTimeFriendly = dateFnsDistanceInWords(card.creationTime);
      app.ports.cardFetched.send(card);
    });
  });

  /*
    port fetchCardVolunteers : String -> Cmd msg
  */
  app.ports.fetchCardVolunteers.subscribe(function(id) {
    database.ref('card-volunteers/' + id).once('value', function(snapshot) {
      var volunteers = [];
      snapshot.forEach(function(user) {
        volunteers.push(user.val());
      });
      app.ports.cardVolunteersFetched.send(volunteers);
    });
  });

  app.ports.fetchUserCards.subscribe(function(id) {
    dbCards.orderByChild('authorId').equalTo(id).once('value', function(snapshot) {
      var cards = [];
      snapshot.forEach(function(card) {
        card = card.val();
        card.creationTimeFriendly = dateFnsDistanceInWords(card.creationTime);
        cards.push(card);
      });
      app.ports.userCardsFetched.send(cards);
    });
  });

  app.ports.createCard.subscribe(function(card) {
    var updates = {};
    var cardId = dbCards.push().key;
    card.id = cardId;
    card.creationTime = +new Date();
    updates['/cards/' + cardId] = card;
    database.ref()
      .update(updates)
      // .then(getCards)
      .catch(function(error) {
        console.error('## error during [pushing card]:', card, error);
      });
  });

  /*
    port fetchUser : { id: String, purpose: String } -> Cmd msg
      o.purpose "openUserPage" | "openChatPage"
  */
  app.ports.fetchUser.subscribe(function(o) {
    database.ref('users/' + o.id).once('value', function(snapshot) {
      var userInDb = snapshot.val();

      if (userInDb) {
        switch (o.purpose) {
          case 'openUserPage':
            app.ports.activeUserFetched.send(userInDb);
            break;
          case 'openChatPage':
            app.ports.userFetched.send(userInDb);
        }
      }
    });
  });

  /*
    port fetchUserTakenCards : String -> Cmd msg
  */
  app.ports.fetchUserTakenCards.subscribe(function(userId) {
    database.ref('user-taken-cards/' + userId).limitToLast(12).once('value', function(snapshot) {
      var cards = [];
      snapshot.forEach(function(card) {
        card = card.val();
        card.creationTimeFriendly = dateFnsDistanceInWords(card.creationTime);
        cards.push(card);
      });
      app.ports.userTakenCardsFetched.send(cards);
    });
  });

  /*
    port updateKarma : {authorId : String, cardId : String, karma : Int} -> Cmd msg
  */
  app.ports.updateKarma.subscribe(function(o) {
    var updates = {};
    updates['cards/' + o.cardId + '/karma'] = o.karma;
    database.ref()
      .update(updates)
      .then(function() {
        // karma updated
      })
      .catch(function(error) {
        console.error('## error during [updating karma]', o.karma, 'for card:', o.cardId, error);
      });
  });

  /*
    port takeCard : { user : User, card : Card } -> Cmd msg
  */
  app.ports.takeCard.subscribe(function(o) {
    var updates = {};
    updates['card-volunteers/' + o.card.id + '/' + o.user.uid] = o.user;
    updates['user-taken-cards/' + o.user.uid + '/' + o.card.id] = o.card;
    var authorNotificationId = database.ref('user-notifications/' + o.card.authorId).push().key;
    updates['user-notifications/' + o.card.authorId + '/' + authorNotificationId] = {
      id: authorNotificationId,
      name: 'userTookCard',
      read: false,
      cardId: o.card.id,
      userId: o.user.uid,
      cardAuthorId: o.card.authorId,
      userName: o.user.name
    };
    database.ref()
      .update(updates)
      .then(function() {
        console.info('## volunteer', o.user.uid, 'added to', o.card.id);
  
        database.ref('card-volunteers/' + o.card.id).once('value', function(snapshot) {
        var volunteers = [];
        snapshot.forEach(function(user) {
          volunteers.push(user.val());
        });
        app.ports.cardVolunteersFetched.send(volunteers);
      });
      })
      .catch(function(error) {
        console.error('## error during [adding volunteer]', o.user.uid, 'to card:', o.card.id, error);
      });
  });

  /*
    port removeCard : Card -> Cmd msg
  */
  app.ports.removeCard.subscribe(function(card) {
    database.ref('card-volunteers/' + card.id).once('value', function(snapshot) {
      var volunteers = [];
      snapshot.forEach(function(volunteer) {
        volunteers.push(volunteer.key());
      });

      var updates = {};
      updates['cards/' + card.id] = null;
      updates['card-volunteers/' + card.id] = null;
      volunteers.forEach(function(volunteerId) {
        updates['user-taken-cards/' + volunteerId + '/' + card.id] = null;
      });
      database.ref()
        .update(updates)
        .then(function() {
          // card removed
          app.ports.cardRemoved.send(card);
        })
        .catch(function(error) {
          console.error('## error during [removing card]:', card.id, error);
        });
    });
  });


  function createRoom(roomId, authorId, volunteerId, cardAuthorName) {
    var roomExists = false;

    var updates = {};
    updates['room-metadata/' + roomId + '/users/' + authorId] = true;
    updates['room-metadata/' + roomId + '/users/' + volunteerId] = true;
    updates['user-rooms/' + authorId + '/' + roomId] = true;
    updates['user-rooms/' + volunteerId + '/' + roomId] = true;
    var volunteerNotificationId = database.ref('user-notifications/' + volunteerId).push().key;
    updates['user-notifications/' + volunteerId + '/' + volunteerNotificationId] = {
      id: volunteerNotificationId,
      name: 'userAssignedToCard',
      read: false,
      cardId: roomId,
      userId: volunteerId,
      cardAuthorId: authorId,
      userName: cardAuthorName
    };

    database.ref()
      .update(updates)
      .then(function() {
        
      })
      .catch(function(error) {
        console.error('## error during [creating room]:', roomId, 'for users:', authorId, volunteerId, error);
      });
  }


  /*
    port assignVolunteer : { card : Card, user : User, userName : String } -> Cmd msg
  */
  app.ports.assignVolunteer.subscribe(function(o) {
    var updates = {};
      database.ref('card-volunteers/' + o.card.id).once('value', function(snapshot) {
        snapshot.forEach(function(volunteer) {
          updates['user-taken-cards/' + volunteer.key + '/' + o.card.id + '/assignedTo'] = o.user.uid;
        });

        updates['cards/' + o.card.id + '/assignedTo'] = o.user.uid;
        // updates['rooms/']

        database.ref()
          .update(updates)
          .then(function() {
            createRoom(o.card.id, o.card.authorId, o.user.uid, o.userName);
          })
          .catch(function(error) {
            console.error('## error during [assigning volunteer]:', o.user.uid, 'for card:', o.card.id, error);
          });
      });
  });

  /*
    port markNotificationsAsRead : { userId : String, notificationIdList : List String } -> Cmd msg
  */
  app.ports.markNotificationsAsRead.subscribe(function(o) {
    var updates = {};
    o.notificationIdList.forEach(function(notificationId) {
      updates['user-notifications/' + o.userId + '/' + notificationId + '/read'] = true;
    });
    database.ref()
      .update(updates)
      .then(function() {})
      .catch(function(error) {
        console.error('## error during [marking notifications as read]:', o.notificationIdList, 'for user:', o.userId, error);
      });
  });

  app.ports.persistCardText.subscribe(function(cardText) {
    if (!window.localStorage) return;
    localStorage.setItem('cardText', cardText);
  });

  if (window.localStorage) {
    var cardText = localStorage.getItem('cardText');
    if (cardText) {
      app.ports.cardTextFetched.send(cardText);
    }
  }

  database.ref('users-online').on('child_added', function(snapshot) {
    app.ports.onlineUserAdded.send(snapshot.key);
  });
  database.ref('users-online').on('child_removed', function(snapshot) {
    app.ports.onlineUserRemoved.send(snapshot.key);
  });

  // CHAT

  app.ports.fetchChatMessages.subscribe(fetchChatMessages);

  // port fetchChatMessages : { chatId : String, lastMessageId : String } -> Cmd msg
  function fetchChatMessages(o) {
    var chatId = o.chatId;
    var lastMessageId = o.lastMessageId;
    var pageSize = 12;
    var ref = database
      .ref('room-messages/' + chatId)
      .limitToLast(pageSize);
    var needToRemoveLast = false;

    if (lastMessageId) {
      needToRemoveLast = true;
      ref = ref.endAt(null, lastMessageId)
    }

    ref.once('value', function(snap) {
      var messages = [];

      snap.forEach(function(im) {
        messages.push(im.val());
      });

      if (needToRemoveLast) {
        // убираем последнее, т.к. использовался lastMessageId и это сообщение у нас уже есть
        messages.pop();
      }

      app.ports.chatMessagesFetched.send({chatId: chatId, messages: messages});
    });
  }


  // var watchingChatId;
  // app.ports.watchChatMessages.subscribe(function(chatId) {
  //   if (watchingChatId && watchingChatId !== chatId) {
  //     database.ref('room-messages/' + watchingChatId).off();
  //   }
  //   // TODO (salnikov): даже после unwatch все равно надо фильтровать от дубликатов
  //   watchingChatId = chatId;
  //   database.ref('room-messages/' + chatId).limitToLast(12).on('child_added', function(im) {
  //     app.ports.messageAdded.send({chatId: chatId, im: im.val()});
  //   });
  // });
  // app.ports.unwatchChatMessages.subscribe(function(chatId) {
  //   database.ref('room-messages/' + chatId).off();
  // });

  app.ports.sendMessage.subscribe(function(chatMessage) {
    var roomRef = database.ref('room-messages/' + chatMessage.chatId);
    var key = roomRef.push().key;
    var updates = {};
    var im = chatMessage.im;
    im.id = key;
    im.date = firebase.database.ServerValue.TIMESTAMP;
    updates[key] = im;
    roomRef.update(updates)
      .catch(function(error) {
        console.error('## error during [sending message]:', chatMessage, error);
      });
  });

  app.ports.fetchRoomMetadata.subscribe(function(roomId) {
    database.ref('room-metadata/' + roomId)
      .once('value', function(snapshot) {
        var data = snapshot.val();
        var roomMetadata = {
          id: roomId,
          users: Object.keys(data.users)
        };
        app.ports.roomMetadataFetched.send(roomMetadata);
      });
  });

  // id of DOMNode; count of children should be when scroll to fire
  // port scrollElementToEnd : { elementId : String, count : Int } -> Cmd msg
  app.ports.scrollElementToEnd.subscribe(function(o) {
    // все действа с домом делать нужно после отрисовки
    requestAnimationFrame(function() {
      var el = document.getElementById(o.elementId);
      if (el) {
        hasEnoughChildren(el, o.count, function() {
          el.scrollTop = el.scrollHeight;
        });
      }
    });
  });

  window.onresize = function() {
    if (app === undefined) return;
    app.ports.windowResized.send(window.innerHeight || document.documentElement.clientHeight);
  };

  // port enableChatHistoryInfiniteScroll : { elementId : String, chatId : String, lastMessageId : String } -> Cmd msg
  app.ports.enableChatHistoryInfiniteScroll.subscribe(function(o) {
    requestAnimationFrame(function() {
      var el = document.getElementById(o.elementId);
      if (el) {
        hasEnoughChildren(el, 12, function() {
          // timeout нужен для того, чтобы подписаться после того, как мы доскролим до конца
          setTimeout(function() {
            var thirdChild = el.children[2];
            if (thirdChild) {

              function onScroll() {
                // if (isElementInViewport(thirdChild)) {
                if (el.scrollTop < 100) {
                  fetchChatMessages(o);
                  preserveScroll(el);
                  el.removeEventListener('scroll', onScroll);
                }
              }

              el.addEventListener('scroll', onScroll);
            }
          }, 500)
        });
      }
    });
  });

  function preserveScroll(el, callback) {
    var lastScrollHeight = el.scrollHeight;
    var started = false;

    function checkHeight() {
      if (el.scrollHeight > lastScrollHeight) {
        started = true;
        requestAnimationFrame(checkHeight);
        el.scrollTop = el.scrollTop + (el.scrollHeight - lastScrollHeight);

        lastScrollHeight = el.scrollHeight;
      } else {
        if (started) {
          if (callback) callback();
        } else {
          requestAnimationFrame(checkHeight);
        }
      }
    }

    requestAnimationFrame(checkHeight);
  }

  function hasEnoughChildren(el, childCount, callback) {
    function onChildAdded() {
      if (el.children.length === childCount) {
        callback();
        el.removeEventListener('DOMNodeInserted', onChildAdded);
      }
    }

    // детей столько же, случай при переносе строки в инпуте, надо чтоб высота инпута обновилась
    if (el.children.length === childCount) {
        el.scrollTop = el.scrollHeight;
        callback();
    } else {
      // детей меньше, случай при открытии страницы, когда не все дети еще добавились в дом
      el.addEventListener('DOMNodeInserted', onChildAdded);
    }
  }

  function isElementInViewport(el) {
      var rect = el.getBoundingClientRect();

      return (
          rect.top >= 0 &&
          rect.left >= 0 &&
          rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
          rect.right <= (window.innerWidth || document.documentElement.clientWidth)
      );
  }
</script>
</html>